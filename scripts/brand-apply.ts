#!/usr/bin/env tsx
/**
 * Brand Apply Script
 *
 * Applies brand.config.ts settings throughout the codebase.
 * Run with: pnpm brand:apply
 */

import * as fs from "node:fs";
import * as path from "node:path";
import { execSync } from "node:child_process";
import { DEFAULT_BRAND, type BrandConfig } from "./brand-types";

const ROOT = path.resolve(import.meta.dirname, "..");

// ANSI colors
const c = {
  reset: "\x1b[0m",
  bright: "\x1b[1m",
  dim: "\x1b[2m",
  cyan: "\x1b[36m",
  green: "\x1b[32m",
  yellow: "\x1b[33m",
  red: "\x1b[31m",
};

function logStep(step: string) {
  console.log(`\n${c.cyan}â–¸${c.reset} ${c.bright}${step}${c.reset}`);
}

function logSuccess(message: string) {
  console.log(`  ${c.green}âœ“${c.reset} ${message}`);
}

function logSkip(message: string) {
  console.log(`  ${c.yellow}â—‹${c.reset} ${c.dim}${message}${c.reset}`);
}

function logError(message: string) {
  console.log(`  ${c.red}âœ—${c.reset} ${message}`);
}

/**
 * Load brand config or use defaults
 */
async function loadConfig(): Promise<BrandConfig> {
  const configPath = path.join(ROOT, "brand.config.ts");

  if (!fs.existsSync(configPath)) {
    console.log(`${c.yellow}âš ${c.reset} No brand.config.ts found. Using default Nebutra branding.`);
    console.log(`  Run ${c.cyan}pnpm brand:init${c.reset} to create a custom brand config.\n`);
    return DEFAULT_BRAND;
  }

  try {
    // Dynamic import of the config
    const configModule = await import(configPath);
    return configModule.default as BrandConfig;
  } catch (error) {
    console.error(`${c.red}Error loading brand.config.ts:${c.reset}`, error);
    process.exit(1);
  }
}

/**
 * Replace all occurrences in a file
 */
function replaceInFile(filePath: string, replacements: Array<[string | RegExp, string]>): boolean {
  if (!fs.existsSync(filePath)) return false;

  let content = fs.readFileSync(filePath, "utf-8");
  let modified = false;

  for (const [search, replace] of replacements) {
    const newContent = content.replace(search, replace);
    if (newContent !== content) {
      content = newContent;
      modified = true;
    }
  }

  if (modified) {
    fs.writeFileSync(filePath, content, "utf-8");
  }

  return modified;
}

/**
 * Copy custom assets if they exist
 */
function copyCustomAssets(config: BrandConfig): void {
  logStep("Copying custom assets");

  const customAssetsDir = path.join(ROOT, "brand.config", "assets");
  const targetAssetsDir = path.join(ROOT, "packages", "brand", "assets");

  if (!fs.existsSync(customAssetsDir)) {
    logSkip("No custom assets found in brand.config/assets/");
    return;
  }

  // Copy logo files
  const logoDir = path.join(customAssetsDir, "logo");
  if (fs.existsSync(logoDir)) {
    const targetLogoDir = path.join(targetAssetsDir, "logo");
    const files = fs.readdirSync(logoDir);
    for (const file of files) {
      fs.copyFileSync(path.join(logoDir, file), path.join(targetLogoDir, file));
      logSuccess(`Copied logo/${file}`);
    }
  }

  // Copy favicon files
  const faviconDir = path.join(customAssetsDir, "favicon");
  if (fs.existsSync(faviconDir)) {
    const targetFaviconDir = path.join(targetAssetsDir, "favicon");
    const files = fs.readdirSync(faviconDir);
    for (const file of files) {
      fs.copyFileSync(path.join(faviconDir, file), path.join(targetFaviconDir, file));
      logSuccess(`Copied favicon/${file}`);
    }
  }
}

/**
 * Update packages/brand/src/metadata.ts
 */
function updateBrandMetadata(config: BrandConfig): void {
  logStep("Updating brand metadata");

  const metadataPath = path.join(ROOT, "packages", "brand", "src", "metadata.ts");

  const newContent = `/**
 * ${config.brand.name} Brand Metadata
 * Central source of truth for brand identity
 * 
 * AUTO-GENERATED by pnpm brand:apply
 * Edit brand.config.ts instead of this file.
 */

export const brand = {
  name: "${config.brand.name}",
  tagline: "${config.brand.tagline}",
  description: "${config.brand.description}",
  
  // Official domains
  domains: {
    landing: "${config.domains.landing}",
    app: "${config.domains.app}",
    api: "${config.domains.api}",
    studio: "${config.domains.studio}",
    cdn: "${config.domains.cdn}",
  },
  
  // Social links
  social: {
    twitter: "${config.social.twitter || ""}",
    github: "${config.social.github || ""}",
    discord: "${config.social.discord || ""}",
    linkedin: "${config.social.linkedin || ""}",
  },
} as const;

/**
 * Brand Colors
 * Primary palette derived from design system
 */
export const colors = ${JSON.stringify(config.colors, null, 2)} as const;

/**
 * Typography
 */
export const typography = {
  fontFamily: {
    sans: '"Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
    mono: '"JetBrains Mono", "Fira Code", Consolas, monospace',
    display: '"Cal Sans", "Inter", sans-serif',
  },
  
  // Font weights
  fontWeight: {
    normal: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
  },
} as const;

/**
 * Logo asset paths (relative to package)
 */
export const logoAssets = {
  // Default logo
  default: "assets/logo/logo-color.svg",
  
  // Variants
  color: "assets/logo/logo-color.svg",
  inverse: "assets/logo/logo-inverse.svg",
  mono: "assets/logo/logo-mono.svg",
  
  // Localized
  en: "assets/logo/logo-en.svg",
  zh: "assets/logo/logo-zh.svg",
  zhEn: "assets/logo/logo-zh-en.svg",
  
  // Layouts
  horizontalEn: "assets/logo/logo-horizontal-en.svg",
  horizontalZh: "assets/logo/logo-horizontal-zh.svg",
  verticalEn: "assets/logo/logo-vertical-en.svg",
  verticalZh: "assets/logo/logo-vertical-zh.svg",
} as const;

/**
 * Favicon assets
 */
export const faviconAssets = {
  ico: "assets/favicon/favicon.ico",
  svg: "assets/favicon/favicon.svg",
  apple: "assets/favicon/apple-touch-icon.png",
  android192: "assets/favicon/android-chrome-192x192.png",
  android512: "assets/favicon/android-chrome-512x512.png",
} as const;

/**
 * OG Image dimensions
 */
export const ogImageDimensions = {
  default: { width: 1200, height: 630 },
  twitter: { width: 1200, height: 600 },
  square: { width: 1200, height: 1200 },
} as const;

export type BrandColors = typeof colors;
export type BrandTypography = typeof typography;
export type LogoAssets = typeof logoAssets;
`;

  fs.writeFileSync(metadataPath, newContent, "utf-8");
  logSuccess("Updated packages/brand/src/metadata.ts");
}

/**
 * Update package.json files with new scope
 */
function updatePackageScopes(config: BrandConfig): void {
  logStep("Updating package scopes");

  const oldScope = "@nebutra";
  const newScope = config.packageScope;

  if (oldScope === newScope) {
    logSkip("Package scope unchanged");
    return;
  }

  // Find all package.json files
  const packagesDir = path.join(ROOT, "packages");
  const appsDir = path.join(ROOT, "apps");

  const packageDirs = [
    ...fs.readdirSync(packagesDir).map((d) => path.join(packagesDir, d)),
    ...fs.readdirSync(appsDir).map((d) => path.join(appsDir, d)),
  ];

  for (const dir of packageDirs) {
    const pkgPath = path.join(dir, "package.json");
    if (!fs.existsSync(pkgPath)) continue;

    const content = fs.readFileSync(pkgPath, "utf-8");
    const newContent = content.replace(new RegExp(oldScope, "g"), newScope);

    if (content !== newContent) {
      fs.writeFileSync(pkgPath, newContent, "utf-8");
      logSuccess(`Updated ${path.relative(ROOT, pkgPath)}`);
    }
  }

  // Update root package.json
  const rootPkgPath = path.join(ROOT, "package.json");
  replaceInFile(rootPkgPath, [[new RegExp(oldScope, "g"), newScope]]);
}

/**
 * Update README files from templates
 */
function updateREADMEs(config: BrandConfig): void {
  logStep("Updating README files");

  const templates = [
    { template: "README.template.md", output: "README.md" },
    { template: "README.zh-CN.template.md", output: "README.zh-CN.md" },
  ];

  for (const { template, output } of templates) {
    const templatePath = path.join(ROOT, template);
    const outputPath = path.join(ROOT, output);

    if (!fs.existsSync(templatePath)) {
      logSkip(`Template ${template} not found`);
      continue;
    }

    let content = fs.readFileSync(templatePath, "utf-8");

    // Replace placeholders
    const replacements: Record<string, string> = {
      "{{brand.name}}": config.brand.name,
      "{{brand.tagline}}": config.brand.tagline,
      "{{brand.description}}": config.brand.description,
      "{{company.name}}": config.company.name,
      "{{company.nameCN}}": config.company.nameCN || config.company.name,
      "{{company.email}}": config.company.email,
      "{{company.year}}": String(config.company.year),
      "{{domains.landing}}": config.domains.landing,
      "{{domains.app}}": config.domains.app,
      "{{domains.api}}": config.domains.api,
      "{{repo.owner}}": config.repo.owner,
      "{{repo.name}}": config.repo.name,
      "{{repo.full}}": `${config.repo.owner}/${config.repo.name}`,
      "{{social.twitter}}": config.social.twitter || "",
      "{{social.github}}": config.social.github || "",
      "{{social.discord}}": config.social.discord || "",
      "{{colors.primary.500}}": config.colors.primary[500],
      "{{colors.accent.500}}": config.colors.accent[500],
      "{{packageScope}}": config.packageScope,
    };

    for (const [placeholder, value] of Object.entries(replacements)) {
      content = content.replace(new RegExp(placeholder.replace(/[{}]/g, "\\$&"), "g"), value);
    }

    // Handle vision pillars
    if (config.brand.vision?.pillars) {
      const visionList = config.brand.vision.pillars
        .map((p) => `- ${p.word}: ${p.meaning}`)
        .join("\n");
      content = content.replace("{{brand.vision}}", visionList);
    }

    // Handle license exemptions
    const exemptList = config.license.commercialExempt.join(", ");
    content = content.replace("{{license.commercialExempt}}", exemptList);

    fs.writeFileSync(outputPath, content, "utf-8");
    logSuccess(`Generated ${output}`);
  }
}

/**
 * Update environment variables template
 */
function updateEnvTemplate(config: BrandConfig): void {
  logStep("Updating .env.example");

  const envPath = path.join(ROOT, ".env.example");
  if (!fs.existsSync(envPath)) {
    logSkip(".env.example not found");
    return;
  }

  const replacements: Array<[RegExp, string]> = [
    [/NEXT_PUBLIC_APP_URL=.*/g, `NEXT_PUBLIC_APP_URL=https://${config.domains.app}`],
    [/NEXT_PUBLIC_API_URL=.*/g, `NEXT_PUBLIC_API_URL=https://${config.domains.api}`],
  ];

  if (replaceInFile(envPath, replacements)) {
    logSuccess("Updated .env.example");
  } else {
    logSkip("No changes needed");
  }
}

/**
 * Main
 */
async function main() {
  console.log(`
${c.cyan}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                           â•‘
â•‘   ${c.bright}ğŸ¨ Applying Brand Configuration${c.reset}${c.cyan}                        â•‘
â•‘                                                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${c.reset}
`);

  const config = await loadConfig();

  console.log(`Brand: ${c.bright}${config.brand.name}${c.reset}`);
  console.log(`Scope: ${c.dim}${config.packageScope}${c.reset}`);

  // Apply changes
  copyCustomAssets(config);
  updateBrandMetadata(config);
  updatePackageScopes(config);
  updateREADMEs(config);
  updateEnvTemplate(config);

  // Summary
  console.log(`
${c.green}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${c.reset}
${c.bright}âœ¨ Brand applied successfully!${c.reset}

${c.cyan}Next steps:${c.reset}

1. Review the changes:
   ${c.dim}git diff${c.reset}

2. Build the project:
   ${c.cyan}pnpm build${c.reset}

3. Start development:
   ${c.cyan}pnpm dev${c.reset}
`);
}

main().catch(console.error);
